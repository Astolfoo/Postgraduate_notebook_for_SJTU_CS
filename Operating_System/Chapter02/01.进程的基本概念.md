## 一、程序的顺序执行及其特征
#### 1.程序的顺序执行

通常把一个应用程序分成若干个程序段，在各程序之间，必须**按照某种先后顺序执行，仅当前一操作（程序段）执行完之后，才可以执行后继操作**。

例如，在进行计算时，总是输入用户的程序和数据，然后进行计算，最后才能打印计算结果。
```
S1:a:=x+y;
S2:b:=a-5;
S3:c:=b+1;
```
程序的顺序执行如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/15.PNG)

#### 2.程序顺序执行时的特征

  - （1）顺序性
  - （2）封闭性
  - （3）可再现性
 
## 二、前趋图
前趋图（Precedence Graph）是一一个**有向无循环图**，记为DAG（Directed Acyclic Graph），用于描述进程之间执行的前后关系。

图中的每个结点可用于描述一个程序段或进程，乃至一条语句；结点间的有向边则用于表示两个结点之间存在的`偏序(Partial Order)`或`前趋关系(Precedence Relation)“→”。`

→={(Pi, Pj)|Pi must complete before Pj may start}, 如果`(Pi, Pj)∈→`,可写成`Pi→Pj`，称`Pi`是`Pj`的直接前趋，而称Pj是Pi的直接后继。

在前趋图中，把没有前趋的结点称为`初始结点(Initial Node)`，把没有后继的结点称为`终止结点(Final Node)`。

每个结点还具有一个`重量(Weight)`，用于表示该结点所含有的程序量或结点的执行时间。 

如下图中的前趋关系图：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/16.png)

图中a的前趋关系如下：
```
P1→P2, P1→P3, P1→P4, P2→P5, P3→P5, P4→P6, P4→P7, P5→P8, P6→P8, P7→P9, P8→P9
或表示为：
       P={P1, P2, P3, P4, P5, P6, P7, P8, P9}
→={ (P1, P2), (P1, P3), (P1, P4), (P2, P5), (P3, P5), (P4, P6), (P4, P7),
        (P5, P8), (P6, P8), (P7, P9), (P8, P9)} 
```
注意点：对于前趋图中必须不存在循环，但在b中却存在如下的前趋关系：
```
S2→S3, S3→S2 
```

## 三、程序的并发执行及其特征
#### 1.程序的并发执行
前趋图如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/17.png)

对于该图存在如下的前趋关系:
```
Ii→Ci，Ii→Ii+1, Ci→Pi, Ci→Ci+1，Pi→Pi+1
```
而`Ii+1`和`Ci`及`Pi-1`是重迭的，亦即在`Pi-1`和`Ci`以及`Ii+1`之间，可以并发执行。 对于具有下述四条语句的程序段：
```
         S1: a∶=x+2
         S2: b∶=y+4
         S3: c∶=a+b
         S4: d∶=c+b 
```
所以四条语句的前趋关系图如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/18.png)

从关系图中，可以看出：S3必须在a和b赋值之后方可执行；S4必须在S3之后执行；但是S1和S2则是可以并行执行，彼此互不依赖。

#### 2.程序并发执行时的特征

  - 间断性
  
        并发程序之间相互制约
        执行——————暂停执行——————执行
  - 失去封闭性
  
        多个程序共享全机资源
        执行状态受外界因素影响
        
  - 不可再现性
  
        程序经过多次执行之后，虽然其执行时的环境和初始条件都相同，但是得到的结果却各不相同。
        
不可再现性的例子：有两个循环程序A和B，它们共享一个变量N。程序A每执行一次时，都要做N∶=N+1操作；程序B每执行一次时， 都要执行Print(N)操作，然后再将N置成“0”。程序A和B以不同的速度运行。 可能出现的三种情况（假设某时刻变量N的值为n）

       (1) N∶=N+1在Print(N)和N∶=0之前，此时得到的N值分别为n+1, n+1, 0。
       (2) N∶=N+1在Print(N)和N∶=0之后，此时得到的N值分别为n, 0, 1。
       (3) N∶=N+1在Print(N)和N∶=0之间，此时得到的N值分别为n, n+1, 0。 

## 四、进程的特征与状态
在多道程序环境下，程序的执行属于并发执行。此时的程序已经失去了封闭性，而且具有了间断性和不可再现性的特征。
#### 1.进程的特征
  
  - 结构特征
  
  通常的程序是不能并发执行的，为使得程序（数据）能独立运行，就为其配置了进程控制块，即PCB（Process Control Block），而由程序段、相关的数据段和PCB三部分构成了进程实体。
  
        进程 = 进程实体
        创建进程 ＝ 创建进程实体中的ＰＣＢ
        撤销进程　＝　撤销进程实体中的ＰＣＢ
  
  - 多态性
  
  进程的实质就是进程实体的一次执行过程，因此，多态性是进程的最基本的特征。进程实体有生命周期。
  
  - 并发性
  
  并发性是实体的重要特征，也是OS的重要特征，引入进程的目的是为了使得进程实体能和其他的进程并发执行，而程序（没有建立PCB）是不能并发执行的。
  
  - 异步性
  
#### 2.进程的定义
对进程，有很多人从不同的角度去进行了定义，但是其中较为典型的定义如下：

    (1) 进程是程序的一次执行。
    (2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
    (3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

而在引入了进程实体的概念之后，就可以把传统OS中的进程定义为：**“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”**。

#### 3.进程的三种基本状态
进程执行的时间间断性决定了进程可能具有多种状态，事实上，运行中的进程可能具有以下三种状态：

  - 就绪（Ready）状态
    
         当进程已分配到除CPU以外的所有资源之后，只要获得CPU，便可立即执行，进程此时的状态就叫做是就绪状态。
         
         在一个系统中处于就绪状态的进程可能有多个，通常将它排成一个队列，称为就绪队列。
         
  - 执行状态
  
          进程已获得ＣＰＵ，其程序正在执行。
          
          单处理机：一个进程处于执行状态
          
          多处理机：多个进程处于执行状态
  - 阻塞状态（等待状态）
  
          正在执行的进程由于发生某事件而暂时无法执行时，就放弃处理机而处于暂停状态。即进程的执行收到了阻塞，于是就把这种状态称为阻塞状态（等待状态）
      
      导致进程阻塞的典型事件：
      
          请求Ｉ／Ｏ
          申请缓冲空间等。
          
       阻塞队列：将处于阻塞状态的进程排成的队列。
       
       根据阻塞原因，把处于阻塞状态的进程排成多个队列。

进程中的三种基本状态及其转换关系如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/19.PNG)

#### 4.挂起状态（静止状态）
定义：使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。这种静止状态称为**挂起状态**。

**引入挂起状态的原因**

    （1）终端用户的请求：当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。
    （2）父进程请求：父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
    （3）负荷调节的需要：当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以便系统能正常运行。
    （4）操作系统的需要：OS有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。

**进程状态之间的转换**
在引入挂起状态后，又将增加从挂起状态（静止状态）到非挂起状态（活动状态）的转换；或者相反。

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/20.PNG)

图中情况分析如下：

   （1）活动就绪→静止就绪
   
            活动就绪状态Readya：当进程处于未被挂起的就绪状态时。
            静止就绪状态Readys：当用挂起原语suspend将进程挂起后，该进程便转换为静止就绪状态，处于Readys状态的进程不再被调度执行。
    
   （2）活动阻塞→静止阻塞
   
            活动阻塞状态Blockeda：进程处于未被挂起的阻塞状态时。
            静止阻塞状态Blockeds：当用Suspend原语将处于活动阻塞状态的进程挂起后，进程便转换为静止阻塞状态。处于该状态的进程在其所期待的事件出现后，将从静止阻塞变为静止就绪。

   （3）静止就绪→活动就绪

            处于Readys状态的进程，若用激活原语Active激活后，该进程将转变为Readya状态。
            
  （4）静止阻塞→活动阻塞
  
            处于Blockeds状态的进程，若用激活原语Active激活后，进程将转变为Blockeda状态。

#### 5.创建状态和终止状态
**5.1 创建进程**

创建进程的两个步骤：

  - 为新进程创建PCB，并填写必要的管理信息
  - 把该进程转入就绪状态并插入就绪队列
  
当一个新进程被创建时，进程已拥有了自己的PCB，但进程自身还未进入主存，即创建工作尚未完成，进程还不能被调度运行，其所处的状态就是创建状态。

引入创建状态的原因

  - 保证进程调度必须在创建工作完成后进行，以确保对PCB操作的完整性。
  - 增加了管理的灵活性，操作系统可以根据系统性能或主存容量的限制，推迟创建状态进程的提交。

对于处于创建状态的进程，获得了其所必需的资源，以及对其PCB初始化工作完成后，进程状态便可由创建状态转入就绪状态。

**5.2 终止进程**

终止进程的两个步骤：

  - 等待操作系统进行善后处理
  - 将其PCB清零，并将PCB空间返还系统

几种情况，使进程进入终止状态

  - 进程到达了自然结束点
  - 出现了无法克服的错误
  - 被操作系统所终结
  - 被其他有终止权的进程所终结

进入终止状态的进程以后不能再执行，但在OS中依然保留一个记录（保存状态码和一些计时统计数据，供其他进程收集）。一旦其他进程完成了对终止状态进程的信息提取之后，OS将删除该进程。

进程中的的五种基本状态及其转换如图所示：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/21.PNG)

而增加了创建状态和终止状态之后，具有挂起状态的进程状态以及转换图如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/22.PNG)

对于以上两种图，进程之间在进行转换时，需要增加以下的情况进行考虑：

     NULL————>创建：一个新进程产生时，该进程处于创建状态
     创建—————>活动就绪：在当前系统的性能和内存容量允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态。
     创建——————>静止就绪：考虑到系统当前资源状况和性能要求，并不分配给新建进程所需资源，主要是主存资源，相应的系统进程将进程状态转为静止就绪状态，对换到外存，不再参与调度，此时进程创建工作尚未完成。
     执行——————>终止：当进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终止，或是被其他有终止权的进程所终结，进程即进入终止状态。

## 五、进程控制块（PCB）
#### 1.进程控制块（PCB）的作用

  - PCB是进程实体的一部分，是操作系统中最重要的记录型数据结构。
  - PCB中记录了操作系统所需的、用于描述进程情况及控制进程运行所需的全部信息。
  - PCB的作用：使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。

OS根据PCB来对并发执行的进程进行控制和管理的。例如：

    1.当OS要调度某进程执行时，要从该进程的PCB中查出其现行状态及优先级；
    2.在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；
    3.进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB；
    4.当进程由于某种原因而暂停执行时，又须将其断点的处理机环境保存在PCB中。
这就说明了**PCB是进程存在的唯一标志**。

**PCB常驻内存的原因**：

PCB可以被OS的多个模块读或修改，如被调度程序、资源分配程序、中断处理程序以及监督和分析程序等读或修改。

因为PCB经常被系统访问，尤其是被运行频率很高的进程及分派程序访问，故PCB应常驻内存。

系统将所有的PCB组织成若干链表，存放在OS中专门开辟的PCB区内。

例如：

    Linux用task_struct数据结构来描述PCB。
    Windows用执行体进程块(EPROCESS)来表示进程对象的基本属性。

#### 2.进程控制块（PCB）中的信息
在进程控制块中，主要存在以下四个方面的信息：

（1）进程标识符：进程标识符用于惟一地标识一个进程。

   - 内部标识符
        
          OS中为每个进程赋予惟一的数字标识符，它通常是一个进程的序号。设置内部标识符主要是为了方便系统使用。
   - 外部标识符
   
          创建者提供，通常由字母、数字组成，往往是由用户（进程）在访问该进程时使用。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。

（2）处理机状态

处理机状态信息主要是由处理机中各种寄存器内容组成的。

处理机在运行时，许多信息都放在寄存器中。

   - 通用寄存器
   - 指令寄存器
   - PSW
   - 用户栈指针
当处理机被中断时，所有这些信息都必须保存在PCB中，以便在该进程重新执行时，能从断点继续执行。

（3）进程调度信息

与进程调度和进程对换有关的信息：

  - 进程状态：指明进程的当前状态，作为进程调度和对换时的依据；
  - 进程优先级：用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；
  - 与进程调度算法有关的信息：进程已等待CPU的时间总和、进程已执行的时间总和等；
  - 事件：指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。

（4）进程控制信息

  - 程序和数据的地址：指进程的程序和数据所在的内存或外存地（首）址，以便再调度到该进程执行时，能从PCB中找到程序和数据；
  - 进程同步和通信机制：指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；
  - 资源清单：是一张列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；
  - 链接指针：给出了本进程（PCB）所在队列中的下一个进程的PCB的首地址。

#### 3.进程控制块（PCB）的组织方式
**3.1 链接方式**

把具有同一状态的PCB，用其中的链接字链接成一个队列。这样，可以形成就绪队列、若干阻塞队列、空白队列等。

对就绪队列常按进程优先级的高低排列，把优先级高的进程的PCB排在队列前面。

根据阻塞原因把处于阻塞状态的进程的PCB排成等待I/O操作完成的队列和等待分配内存的队列等。

PCB链接队列示意图如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/23.PNG)

**3.2 索引方式**

系统根据所有进程的状态建立几张索引表，

索引方式组织PCB的示意图如下：

![](https://github.com/Soler0502H/Postgraduate_notebook_for_SJTU_Software_Program/blob/master/Images/24.PNG)
