进程控制是进程管理中最基本的功能。

进程控制的作用：
  
    1.用于创建一个新进程
    2.终止一个已完成的进程
    3.终止一个因出现某事件而使其无法运行下去的进程
    4.负责进程运行中的状态转换
    
**进程控制一般是由OS的内核来实现的。**

**原语（Primitive）** 是由若干条指令组成的，用于完成一定功能的一个过程。

它与一般过程的区别是：它们是原子操作（Atomic Operation），一个操作中所有动作要么全做要么全不做。它是一个不可分割的基本单位，因此在执行过程中不允许被中断。

原子操作在管态下执行，常驻内存。

**原语的作用**是为了实现进程的通信和控制，系统对进程的控制如不使用原语，就会造成其状态的不确定性，从而达不到进程控制的目的。

## 一、进程的创建
#### 1.进程图
**进程图是用于描述进程家族关系的有向树。**

父进程（Parent Process）：在进程A创建了进程B后，称A是B的父进程。

子进程（Progeny Process）：B是A的子进程。

祖父进程：创建父进程的进程为祖父进程。例如B是K的祖父进程。

祖先（Ancestor）：树的根节点是进程家族的祖先。

**进程间关系的重要性**

    子进程可以继承父进程所拥有的资源
    当子进程被撤消时，应将从父进程那里获得的资源归还给父进程
    在撤消父进程时，也必须同时撤消其所有的子进程
为了标识进程之间的家族关系，在PCB中（P44内部标志符）都设置有家族关系表项，以标明自己的父进程及所有的子进程

#### 2.引起创建进程的事件
再多道程序环境下，只有（作为）进程（时）才能在系统中允许。因此，为使得程序能运行，就必须为其创建进程。导致一个进程去创建另一个进程的典型事件，可以分为以下四类：

  - 用户登录（由系统内核创建新进程）
  
        在分时系统中，系统为每个终端用户建立进程，并插入就绪队列中。

  - 作业调度（由系统内核创建新进程）
  
        在批处理系统中，当作业调度程序按一定的算法调度到某个作业时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入就绪队列。
        
  - 提供服务（由系统内核创建新进程）
  
        当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。

  - 应用请求（基于应用进程由自己创建）

#### 3.进程的创建（Creation of Process）

一旦操作系统发现要求创建新进程的事件后，便会调用进程创建原语Creat()，然后根据以下步骤进行创建一个新的进程：

- 申请空白PCB。

      为新进程申请获得惟一的数字标识符，并从PCB集合中索取一个空白的PCB。

- 为新进程分配资源

      a.为新进程的程序和数据以及用户栈分配必要的内存。显然，此时OS必须知道新进程所需内存大小。
      b.对于批处理作业，其大小可在用户提出创建进程要求时提供。若是应用进程创建子进程，也应是在该进程提出创建进程的请求中给出所需内存大小。
      c.对于交互型作业，用户可以不给出内存要求而由系统分配一定的空间。如新进程要共享某个已在内存的地址空间，则必须建立相应链表。

- 初始化进程控制块

    初始化PCB包括：
          
      a.初始化标识信息，将系统分配的标识符和父进程标识符填入新PCB中。
      b.初始化处理机状态信息，使得程序计数器指向程序的入口地址，使栈指针指向栈顶。
      c.初始化处理机控制信息，使进程的状态设置为就绪状态或者是静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式方式提出高优先级的要求。

- 将新进程插入就绪队列


## 二、进程的终止
#### 1.引起进程终止的事件
  - 正常结束
  在计算机系统中，都应有一个用于表示进程已经运行完成的指示。例如：
  
    a.批处理系统中的Holt指令
    b.分时系统中的LogsOff
  - 异常结束
  在进程运行期间，由于出现了某些错误和故障而迫使进程终止（Termination of Process）。这种情况的异常事件分类很多，常见的情况如下：
  
    越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障等。
  - 外界干预
  外界干预并不是指进程在运行中发生了异常事件，而是指进程应外界的请求而终止运行。主要的干预情况如下：
  
    a.操作员或操作系统干预
    b.父进程请求（父进程具有终止自己的任何子孙进程的权利）
    c.父进程终止


#### 2.进程的终止过程
如果系统发生了要求终止进程的某些事件，OS会直接调用进程终止原语。具体的过程如下：

    a.根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态
    b.若被终止进程正处于执行状态，应立即终止该进程的执行，并设置调度标志为真，用于指示该进程被终止后应重新进行调度，选择一新进程，把处理机分配给它
    c.若该进程还有子孙进程，还应将其所有子进程予以终止
    d.将该进程所拥有的全部资源，或者归还给其父进程或系统
    e.将被终止进程（PCB）从所在队列中移去

## 三、进程的阻塞与唤醒
#### 1.引起进程的阻塞与唤醒的事件
  - 请求系统服务
  
        由资源释放者唤醒
  - 启动某种操作
  
        由中断处理程序或中断进程唤醒
  - 新数据尚未到达
  
        由提供数据的进程唤醒
  - 无新工作可做
  
        当又有进程提出新的发送请求时，才又将发送进程唤醒
#### 2.进程阻塞过程
直接调用Bolck()原语

进程的阻塞是进程自身的主动行为。
#### 3.进程唤醒过程
当被阻塞进程所期待的事件出现时，则有关的进程就会调用唤醒原语Wakeup()，将等待的事件的过程唤醒。

如果在某进程中调用了阻塞原语，则必须在与之相合作的另一进程中或其他相关的进程中，安排唤醒原语，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。

## 四、进程的挂起与激活
#### 1.进程的挂起
利用挂起原语Suspend()将指定进程或处于阻塞状态的进程挂起。

挂起原语Suspend()的执行过程：

      首先检查被挂起进程的状态并进行相应操作（执行态、活动就绪 - 静止就绪； 活动阻塞 - 静止阻塞）。
      为便于用户或父进程考查该进程的运行情况，把该进程的PCB复制到某指定的内存区域。
      最后，若被挂起的进程正在执行，则转向调度程序重新调度，从而将处理机重新分配。

#### 2.进程的激活过程

利用激活原语active()将指定进程激活。

激活原语active()的执行过程：

    激活原语将进程从外存调入内存
    检查该进程的现行状态并进行相应操作（静止就绪-活动就绪； 静止阻塞 - 活动阻塞）。

假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，检查是否要进行重新调度，即比较被激活进程与当前进程的优先级，从而决定处理机的归属问题。




